% !TEX root = ../Thesis.tex
\chapter{Outlook}
\label{c:outlook}


Despite the proposed improvements of the current implementation, the notion of freshness can be extended even further to provide more dynamic approaches.
The introduced implementation offered a great foundation for additiona future work.



\section{Tuneable Consistency}
The introduced implementation sketched in section \ref{c:implementation} reduces the overall consistency of the primary transaction,
to improve the overall response time of the system.\\ 
But since this trade-off between availability and consistency certainly depends on the use case or service requirements, it would be beneficial.
Hence, an extension to the described model could easily allow to adjust the required consistency as needed. 
This could be either done by the mentioned usage of policies, described in section \ref{sec:polcies} or with.

Instead of labeling fixed data placements to receive updates eagerly, we could allow a more flexible approach that ts is sufficient if already placement 
shall receive the update, disregarding its role. The predefined replication state can be therefore omitted. 
Such approaches can then be easily combined with tuneable consistency to allow self adjusting data placements  adapting to individual use cases.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Global Replication Strategies}
This implementation has only introduced the specification of table-level entities like entire data placements to be defined as eagerly or lazily replicated objects.
Although this introduces a high degree of flexibility, it still might be desirable to define certain policies, that entire schemas or even databases automatically 
receive updates lazily, while still ensuring the overall placement constraints.\\
This concept could be extended even further by applying it to a distributed setup of Polypheny, that replicates data autonomously to certain regions based on the given 
configuration. 
This extension could leverage the introduced freshness-awareness to consider off-site locations to be used for even more parallel workload.
This could even include using a more adaptive freshness approach that evaluates the distance to a node to identify suitable locations for retireval.
Since an outdated information fetched from a distant store, will become more outdated during transfer, we can
extend this further to even measure the common round trip time to that store and integrate it into the query specification to identify suitable palcements.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Session-Wide Freshness}
Another addition to freshness could be the extension to also allow the specification
of freshness per session, which avoids specifiyng the freshness for individual statements.
This can be especially useful if the freshness requirements do not really change over time, allowing a quick
possibility to manifest the requirements. Although, they could be extented for individual statements,
that indeed require a more strict form of freshness, it provides a good base line to operate using freshness.
This is especially interesting for applications that usually establish one session, for the majority of its lifetime. 
Such applications currently have to internally define per statement what degree of freshness they might tolerate. 
A session-wide freshness could therefore allow centrally changing the freshness if the requirement changes without having to recompile the application again.
Together with adjustable freshness configurations that might automatically adapt towards recently provided freshness data it would allow
to transform freshness-aware data management to a more adaptive configuration in general.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\todo{Add spacing in chapters to avoid entire blocks of data}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%