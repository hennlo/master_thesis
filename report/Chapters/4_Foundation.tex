% !TEX root = ../Thesis.tex
\chapter{Foundations}
\label{c:Foundation}

This chapter describes concepts and general foundations, which are necessary to supplement 
the contents of this thesis. These foundations are mainly associated with topics on distributed data management.


\section{Polystores}

The decision which data structure to use and built upon is a crucial step for the overall performance of a systems design, as suggested by
H.Plattner and B.Leukert\cite{plattner2015}.\\
While row-oriented data stores might be useful and preferred for write-heavy transactional 
workloads they are rather insufficient for purely analytical workload which would rather benefit from a
column-oriented data store with less write operations\cite{sigmond2008}.\\

Despite the fact that nowadays there exist a variety of Database Management Systems (DBMS) which were originally created with an intention to
support specific scenarios,
applications are getting more complex relying on various requirements and characteristics 
to serve multiple use cases at once.
That is why modern day applications can not solely rely on one storage technology alone. 
Consequently Multi- and Polystore systems have emerged. \\
\\
While multistore database systems aim to combine and manage data across heterogeneous data stores,
polystore systems are essentially based on the idea of combining multistores with
\textit{polyglot persistence}\cite{polypheny2020}.
Polyglot persistence is a term which refers to a practice originated from the concept 
of \textit{polyglot programming} or microservice architectures, to utilize different 
programming languages for different task requirements following a best-fit approach\cite{fowler2011}. \\
Along this paradigm, polystores want to utilize multiple data storage technologies to
fulfill different needs for different application components in order to cope
with mixed and varying workloads.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Data Partitioning}
\label{sec:part}

Beside the utilization of several data storage engines, the data model and structure 
will have an enormous impact on the overall performance. Depending on the query or 
how data is accessed, data partitioning can be used to increase the efficiency and 
maintainability of the system\cite{Agrawal_2004}.\\
The process of data partitioning refers to splitting the data into logically and sometimes even
physically separated fragments.

In general data partitioning can be distinguished between two variations.

\begin{description}
    \item [Vertical Partitioning] is usually applied during the design of a data model inside a 
    database. This involves the creation of tables with fewer columns and therefore using additional 
    tables to store the remainder of columns.\cite{vertical_1984}. This approach is often used in the 
    context of Normalization of a data model\cite{normalization_2012}. 
    \item [Horizontal Partitioning] refers to the partitioning of objects like tables 
    into a disjoint set of rows that can be stored and accessed separetely\cite{horizontal_1982}.
    To support this explicit form of partitioning there exist several partition algorithms.
    The most common ones are List, Range and Hash partitioning. These algorithms can be applied to a
    table based on an arbitary column which results in a fragmentation of the table 
    based on the data values of the selected column.
\end{description}

Data partitioning generally enables a system to process data concurrently and 
to some extent even in parallel. Considering that access to data can be 
efficiently load balanced and therefore enhances the throughput per query.\\

Although data partitioning is often associated with the improvement of query performance.
It can be also be used to simplify the operating of a DBMS cluster and therefore help 
to increase the overall availability.
Through the replication of partition fragments, the data resilience of the system
can be improved. Even if part of the data storage nodes are temporarily not 
reachable, your system still might be fully operational and available due to the 
replication and distribution of data fragments, which is still one of the main 
pursuits of current cloud providers\cite{dbre2017}.

\subsection{Vertical Partitioning}
\subsection{Horizontal Partitioning}

\todo{Or rather an entire chapter with Properties of Distributed Systems/ Data Management}
\section{Temperature-aware Data Management}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{CAP Theorem}
\label{sec:cap}
An essential part of distributed systems is the handling of failures or outages of participating components. 
The \emph{CAP theorem} \cite{brewer:2000} introduced by E. Brewer discusses these scenarios and states, that it is not possible 
to keep the system available while providing global data consistency at the same time \cite{cap2002}. 


Although CAP was essentially introduced to support primarly the differentiation between \emph{Availability} and \emph{Consistency} it only considers the failure scenario.
Therefore, an extension was introduced for the non failure case.
\\
Although the CAP theorem introduced by E. Brewer ... it only captures the aspects in case of a failure.
However, since this should rather be the exception PACELC was introduced \todoMissing{cite} as an extension and an alternative to CAP. While the first 3 letters are merely a permutation of CAP
the new suffix stands for \emph{Else Latency vs. Consistency} and essentially focuses on the non-failure case and to choose between.
This states if the system can be partition tolerant, then we need to choose between availability or consistency. However, if the system cannot
work normally when partitioned then we need to decide on building a consistent system or as system with a lower latency that provides a better average response time \cite{abadi2012}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Data Replication}
In distributed setups...
Cloud providers often tend to use data partitioning to improve the query performance
by replicating certain partitions of data to where it is actually needed\cite{cloudpart_2012}.\\

The different nuances inherently result in the mentioned tradeoffs between availability and consistency as described in section \ref{sec:cap}

\subsection{Eager Replication}
Provides strong consistency among the replicas.
Each update forces all replicas to be updated - synchronous
But you have to give in on availability
since  your transaction only commits after the last replica has finished its write operation. Limiting the performance of this approach to 
the performance of the slowest performing store.
\todoMissing{Insert description}

\subsection{Lazy Replication}
In ints core form only Offers only a weak consistency.
Updates only need to be acknowledged and executed by one store. get lazily replicated to the remaining nodes - asynchronous  
Parallel processing and increased availability because only one node is blocked
However during the convergence period, until all changes have been replicated to all secondary replicas, we are opposed to an inconsistent system state.
This could result in retrieving outdated data, if the client contacts one of the outdated nodes.
hence,  has to be handled with car.

A common extension \todoMissing{cite eventual consistency} is the usage of \emph{Eventual Consistency}
or the decision to adjust the desired level of consistency to increase the availability. 
Eventual consistency is commonly supported within cloud environements and guarantee, if no further updates are made 
during convergence that all accesses to eas replica will evenbtually see the same value and will all be uptodate. 
Multiple nuances exist like quorum ROWA, ROWAA,ect \todoMissing{cite}
\\
Automatically results in \emph{Eventual Consistency}. Lazy replication therefore already have the characteristic of outdated nodes that leave several versions behind.
\todoMissing{Insert}

As pointed out by \cite{cho:2000} utilizing a lazy propagation of updates, immediately leads to different versions of participating data items and thus also to stale data.  



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Concurrency Control}
As describes in Section \ref{sec:cap}, PACELC deals with the trade-off of latency and consistency in non-failure scenarios.
In this context a major and also extensively studied problem  of distributed database systems is concurrency control\todoMissing{Cite}.

- Discuss downsides of SS2PL because eagerly  replicated and not allowing much performance but ensuring high consistency.

\todoMissing{COnvert to bullet points}
\subsection{(SS)2PL}
\subsection{MVCC}
Established for multi-version databases that extend the concept of shadow pages by keeping the complete history or at least multiple versions of each object \cite{bernstein:1982}.
MVCC was introduced by \cite{bernstein:1983}

\subsection{Discussion}
Although, there now exist some work that provides serializable versions of multi-version concurrency control \cite{faleiro:2015}.


